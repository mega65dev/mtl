
; ******** Source: main.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       main.asm
     5                          ;      Purpose:    MTL Runtime (slow 'n' lazy version, NMOS 6502 only no optimisation)
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          zeroPageStart = $10                             ; zero page allocation here.
    13                          

; ******** Source: src\data.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       data.asm
     5                          ;      Purpose:    MTL Runtime ZP Allocation, Macros etc.
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          	
    12                          
    13                          ; ***************************************************************************************************************
    14                          ;
    15                          ;										Zero Page Allocation
    16                          ;
    17                          ; ***************************************************************************************************************
    18                          
    19                          pctr = zeroPageStart						; program counter (address of instruction)
    20                          
    21                          register = zeroPageStart+2 					; current register value.
    22                          
    23                          eac = zeroPageStart+4 						; effective address calculation.
    24                          
    25                          instr = zeroPageStart+6 					; current instruction.
    26                          
    27                          temp0 = zeroPageStart+8 					; working registers.
    28                          
    29                          temp1 = zeroPageStart+10 
    30                          
    31                          nextFreeZero = zeroPageStart + 16 			; memory we can use.
    32                          
    33                          ; ***************************************************************************************************************
    34                          ;
    35                          ;												Macros
    36                          ;
    37                          ; ***************************************************************************************************************
    38                          
    39                          !macro set16 .addr,.value {
    40                          		lda 	#((.value) & $FF)
    41                          		sta 	0+(.addr)
    42                          		lda 	#((.value) >> 8)
    43                          		sta 	1+(.addr)	
    44                          }
    45                          
    46                          !macro 	inc16 .addr {
    47                          		inc 	0+(.addr)
    48                          		bne 	+
    49                          		inc 	1+(.addr)
    50                          +
    51                          }
    52                          
    53                          !macro cmd 	.cmdid,.addr {
    54                          		!byte 	(.cmdid << 4)+((.addr >> 8) & 0x0F)
    55                          		!byte 	(.addr & $FF)
    56                          }		
    57                          
    58                          !macro call .addr {
    59                          		!byte 	((.addr >> 10) & $3F)+$C0
    60                          		!byte 	(.addr >> 2) & $FF		
    61                          }
    62                          
    63                          !macro define .name,.count,.first {
    64                          		!word 	0 							; link to next (filled in later)
    65                          		!byte 	.count 						; number of parameters
    66                          		!byte 	.first 						; first parameter address if more than one (last in R)
    67                          		!text 	.name,0 					; ASCIIZ name.
    68                          		!align 	3,0 

; ******** Source: main.asm
    14                          
    15                          
    16                          ; ***************************************************************************************************************
    17                          ;
    18                          ;					Runtime Header starts here (if not run in test handler, target #0)
    19                          ;
    20                          ; ***************************************************************************************************************
    21                          
    22                          start
    23  2100 4c4021             		jmp 	boot 						; +0  is jump to initial code
    24  2103 00                 		!byte 	0
    25                          execRoutine		
    26  2104 4c5621             		jmp 	execRuntime 				; +4  is opcode execution routine
    27  2107 00                 		!byte 	0
    28                          
    29                          firstProcedure		
    30  2108 c623               		!word	codeSpace 					; +8  is the address of the first procedure.
    31                          
    32                          loadAddress		
    33  210a 0021               		!word 	start  						; +10 is the load address
    34                          
    35                          initStart
    36  210c 0624               		!word 	UnnitialisedVariables 		; +12 is the start of the uninitialised variables.
    37                          
    38                          initEnd
    39  210e 4624               		!word 	EndVariableSpace 			; +14 is the end of the uninitialised variables.
    40                          
    41                          registerAddress
    42  2110 1200               		!word 	register					; +16 is the address of the register
    43                          
    44                          nextFreeZeroAddress 	 						
    45  2112 2000               		!word 	nextFreeZero				; +18 next free zp address.
    46                          
    47                          
    48                          		* = start+64
    49                          
    50                          ; ***************************************************************************************************************
    51                          ;
    52                          ;								Import the system specific code
    53                          ;
    54                          ; ***************************************************************************************************************
    55                          
    56                          		!if target=1 {
    57                          		!source "src/bootmega.asm"
    58                          		} 
    59                          		!if target=2 {

; ******** Source: src\boottest.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       boottest.asm
     5                          ;      Purpose:    MTL Runtime, testbed code.
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          zeroPageStart = $10
    13                          
    14                          variableMax = 32 								; how many variables allowed in test version
    15                          
    16                          boot
    17  2140 78                 		sei
    18  2141 4c4721             		jmp     runApplication
    19                          
    20                          ; ***************************************************************************************************************
    21                          ;
    22                          ;											Print Character in A
    23                          ;
    24                          ; ***************************************************************************************************************
    25                          
    26                          PrintCharacter
    27  2144 4ceeff             		jmp     $FFEE

; ******** Source: main.asm
    60                          
    61                          		}
    62                          
    63                          ; ***************************************************************************************************************
    64                          ;
    65                          ;									Runtime code starts here
    66                          ;
    67                          ; ***************************************************************************************************************
    68                          
    69                          runApplication		
    70  2147 a2ff               		ldx 	#$FF 						; reset the 6502 stack.
    71  2149 9a                 		txs
    72  214a 205b23             		jsr 	ClearMemory 				; erase all memory.
    73  214d 205321             		jsr 	runFirstProc 				; run the first procedure
    74  2150 4c5021             halted:	jmp 	halted		 				; and stop.
    75                          
    76                          runFirstProc		
    77  2153 6c0821             		jmp 	(firstProcedure) 			; execute the first procedure
    78                          
    79                          ; ***************************************************************************************************************
    80                          ;
    81                          ;											Includes
    82                          ;
    83                          ; ***************************************************************************************************************
    84                          

; ******** Source: src\exec.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       exec.asm
     5                          ;      Purpose:    Execute the runtime
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;									Run a code routine following the call
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          execRuntime
    19  2156 18                 		clc
    20  2157 68                 		pla 								; get the start address from the call + 1
    21  2158 6901               		adc 	#1 							; RTS post increments on return.
    22  215a 8510               		sta 	pctr
    23  215c 68                 		pla
    24  215d 6900               		adc 	#0
    25  215f 8511               		sta 	pctr+1
    26                          
    27                          execLoop
    28  2161 a000               		ldy 	#0 							; get instruction (Hi/Lo order)
    29  2163 b110               		lda 	(pctr),y
    30  2165 8517               		sta 	instr+1
    31  2167 c8                 		iny
    32  2168 b110               		lda 	(pctr),y
    33  216a 8516               		sta 	instr
    34                          		;
    35  216c 208223             		jsr 	ShowDebugInfo 				; current state if debugging
    36                          		;
    37  216f a510               		lda 	pctr 						; bump pctr
    38  2171 18                 		clc 
    39  2172 6902               		adc 	#2
    40  2174 8510               		sta 	pctr
    41  2176 9002               		bcc 	+
    42  2178 e611               		inc 	pctr+1
    43                          +
    44  217a a517               		lda 	instr+1 					; get instr MSN and double it, so shift right thrice.
    45  217c 4a                 		lsr
    46  217d 4a                 		lsr
    47  217e 4a                 		lsr
    48  217f 291e               		and 	#$1E 						; force into range
    49  2181 aa                 		tax
    50                          
    51  2182 bd9321             		lda 	execTable,x 				; get address and go there.
    52  2185 8d9121             		sta 	vector
    53  2188 bd9421             		lda 	execTable+1,x
    54  218b 8d9221             		sta 	vector+1
    55  218e 6c9121             		jmp 	(vector)
    56                          
    57                          vector 										; cannot go in ZP if we move B
    58  2191 0000               		!word 	0
    59                          
    60                          execTable
    61  2193 bb21               		!word 	Command_LDR  				; $0x Load Register
    62  2195 c921               		!word 	Command_STR  				; $1x Store Register
    63  2197 d721               		!word 	Command_ADD 				; $2x Add to Register
    64  2199 ea21               		!word 	Command_SUB 				; $3x Sub from Register
    65  219b 4622               		!word 	Command_MUL 				; $4x Multiply into Register
    66  219d 8322               		!word 	Command_DIV 				; $5x Divide into Register
    67  219f fd21               		!word 	Command_AND 				; $6x And into Register
    68  21a1 0f22               		!word 	Command_ORR 				; $7x Or with Register
    69  21a3 2122               		!word 	Command_XOR 				; $8x Xor into Register
    70  21a5 ba22               		!word 	Command_BRA 				; $9x Branch always
    71  21a7 d622               		!word 	Command_BEQ 				; $Ax Branch zero
    72  21a9 df22               		!word 	Command_BPL 				; $Bx Branch positive
    73  21ab e622               		!word 	Command_CALL 				; $Cx Call 6502 routine
    74  21ad e622               		!word 	Command_CALL 				; $Dx Call 6502 routine
    75  21af e622               		!word 	Command_CALL 				; $Ex Call 6502 routine
    76  21b1 e622               		!word 	Command_CALL 				; $Fx Call 6502 routine
    77                          
    78                          notImplemented								; come here when not implemented.
    79  21b3 a2ee               		ldx 	#$EE
    80  21b5 8a                 		txa
    81  21b6 a8                 		tay
    82  21b7 03                 		see
    83                          halt

; ******** Source: main.asm
    85  21b8 4cb821             

; ******** Source: src\simple.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       simple.asm
     5                          ;      Purpose:    Simple Opcodes
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;										0x LDR - Load Register
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          Command_LDR:
    19  21bb 203322             		jsr 	EffectiveAddress
    20  21be b114               		lda 	(eac),y
    21  21c0 8513               		sta 	register+1
    22  21c2 a114               		lda 	(eac,x)
    23  21c4 8512               		sta 	register		
    24  21c6 4c6121             		jmp 	execLoop
    25                          
    26                          ; ***************************************************************************************************************
    27                          ;
    28                          ;										1x STR - Store Register
    29                          ;
    30                          ; ***************************************************************************************************************
    31                          
    32                          Command_STR:
    33  21c9 203322             		jsr 	EffectiveAddress
    34  21cc a513               		lda 	register+1
    35  21ce 9114               		sta 	(eac),y
    36  21d0 a512               		lda 	register		
    37  21d2 8114               		sta 	(eac,x)
    38  21d4 4c6121             		jmp 	execLoop
    39                          
    40                          ; ***************************************************************************************************************
    41                          ;
    42                          ;										2x ADD - Add Register
    43                          ;
    44                          ; ***************************************************************************************************************
    45                          
    46                          Command_ADD:
    47  21d7 203322             		jsr 	EffectiveAddress
    48  21da 18                 		clc
    49  21db a512               		lda 	register		
    50  21dd 6114               		adc 	(eac,x)
    51  21df 8512               		sta 	register
    52  21e1 a513               		lda 	register+1
    53  21e3 7114               		adc 	(eac),y
    54  21e5 8513               		sta		register+1
    55  21e7 4c6121             		jmp 	execLoop
    56                          
    57                          ; ***************************************************************************************************************
    58                          ;
    59                          ;										3x SUB - Sub from Register
    60                          ;
    61                          ; ***************************************************************************************************************
    62                          
    63                          Command_SUB:
    64  21ea 203322             		jsr 	EffectiveAddress
    65  21ed 38                 		sec
    66  21ee a512               		lda 	register		
    67  21f0 e114               		sbc 	(eac,x)
    68  21f2 8512               		sta 	register
    69  21f4 a513               		lda 	register+1
    70  21f6 f114               		sbc 	(eac),y
    71  21f8 8513               		sta		register+1
    72  21fa 4c6121             		jmp 	execLoop
    73                          
    74                          ; ***************************************************************************************************************
    75                          ;
    76                          ;										6x AND - And Register
    77                          ;
    78                          ; ***************************************************************************************************************
    79                          
    80                          Command_AND:
    81  21fd 203322             		jsr 	EffectiveAddress
    82  2200 a512               		lda 	register		
    83  2202 2114               		and 	(eac,x)
    84  2204 8512               		sta 	register
    85  2206 a513               		lda 	register+1
    86  2208 3114               		and 	(eac),y
    87  220a 8513               		sta		register+1
    88  220c 4c6121             		jmp 	execLoop
    89                          
    90                          ; ***************************************************************************************************************
    91                          ;
    92                          ;										7x ORR - Or Register
    93                          ;
    94                          ; ***************************************************************************************************************
    95                          
    96                          Command_ORR:
    97  220f 203322             		jsr 	EffectiveAddress
    98  2212 a512               		lda 	register		
    99  2214 0114               		ora 	(eac,x)
   100  2216 8512               		sta 	register
   101  2218 a513               		lda 	register+1
   102  221a 1114               		ora 	(eac),y
   103  221c 8513               		sta		register+1
   104  221e 4c6121             		jmp 	execLoop
   105                          
   106                          ; ***************************************************************************************************************
   107                          ;
   108                          ;										8x XOR - ExOr Register
   109                          ;
   110                          ; ***************************************************************************************************************
   111                          
   112                          Command_XOR:
   113  2221 203322             		jsr 	EffectiveAddress
   114  2224 a512               		lda 	register		
   115  2226 4114               		eor 	(eac,x)
   116  2228 8512               		sta 	register
   117  222a a513               		lda 	register+1
   118  222c 5114               		eor 	(eac),y
   119  222e 8513               		sta		register+1
   120  2230 4c6121             		jmp 	execLoop
   121                          
   122                          ; ***************************************************************************************************************
   123                          ;
   124                          ;						Effective address calc on instruction, set X = 0 Y = 1
   125                          ;
   126                          ; ***************************************************************************************************************
   127                          
   128                          EffectiveAddress:
   129  2233 a516               		lda 	instr
   130  2235 0a                 		asl 	
   131  2236 8514               		sta 	eac
   132  2238 a517               		lda 	instr+1
   133  223a 290f               		and 	#$0F
   134  223c 2a                 		rol 	
   135  223d 6924               		adc 	#SystemVariables >> 8
   136  223f 8515               		sta 	eac+1
   137  2241 a001               		ldy 	#1
   138  2243 a200               		ldx 	#0

; ******** Source: main.asm
    86  2245 60                 

; ******** Source: src\multiply.asm
     1                          ; *******************************************************************************************
     2                          ; *******************************************************************************************
     3                          ;
     4                          ;       File:           multiply.asm
     5                          ;       Purpose:        Multiply code
     6                          ;      	Created:    	27th December 2020
     7                          ;       Author:         Paul Robson (paul@robson.org.uk)
     8                          ;
     9                          ; *******************************************************************************************
    10                          ; *******************************************************************************************
    11                          
    12                          ; *******************************************************************************************
    13                          ;
    14                          ;							4x MUL - Multiply into register
    15                          ;
    16                          ; *******************************************************************************************
    17                          
    18                          Command_MUL:
    19  2246 203322             		jsr 	EffectiveAddress 			; but value into temp1
    20  2249 b114               		lda 	(eac),y
    21  224b 851b               		sta 	temp1+1
    22  224d a114               		lda 	(eac,x)
    23  224f 851a               		sta 	temp1
    24  2251 a512               		lda 	register 					; register into temp0 and multiply.
    25  2253 8518               		sta 	temp0
    26  2255 a513               		lda 	register+1
    27  2257 8519               		sta 	temp0+1
    28  2259 205f22             		jsr 	Multiply
    29  225c 4c6121             		jmp 	execLoop
    30                          
    31                          ; *******************************************************************************************
    32                          ;
    33                          ;								register := temp0 * temp1
    34                          ;
    35                          ; *******************************************************************************************
    36                          
    37                          Multiply:
    38  225f a900               		lda 	#0 							; zero total.
    39  2261 8512               		sta 	register
    40  2263 8513               		sta 	register+1
    41                          _MultLoop:
    42  2265 4619               		lsr 	temp0+1
    43  2267 6618               		ror 	temp0	
    44  2269 900d               		bcc 	_MultNoAdd
    45  226b 18                 		clc
    46  226c a51a               		lda 	temp1		
    47  226e 6512               		adc 	register
    48  2270 8512               		sta 	register
    49  2272 a51b               		lda 	temp1+1
    50  2274 6513               		adc 	register+1
    51  2276 8513               		sta 	register+1
    52                          _MultNoAdd:
    53  2278 061a               		asl 	temp1
    54  227a 261b               		rol 	temp1+1
    55  227c a518               		lda 	temp0
    56  227e 0519               		ora 	temp0+1
    57  2280 d0e3               		bne 	_MultLoop
    58  2282 60                 		rts

; ******** Source: main.asm
    87                          

; ******** Source: src\divide.asm
     1                          ; *******************************************************************************************
     2                          ; *******************************************************************************************
     3                          ;
     4                          ;       File:           divide.asm
     5                          ;       Purpose:        Divide and Modulus code
     6                          ;      	Created:    	27th December 2020
     7                          ;       Author:         Paul Robson (paul@robson.org.uk)
     8                          ;
     9                          ; *******************************************************************************************
    10                          ; *******************************************************************************************
    11                          
    12                          ; *******************************************************************************************
    13                          ;
    14                          ;							5x DIV - Divide into register
    15                          ;
    16                          ; *******************************************************************************************
    17                          
    18                          Command_DIV:
    19  2283 203322             		jsr 	EffectiveAddress 			; but value into temp1
    20  2286 b114               		lda 	(eac),y
    21  2288 8519               		sta 	temp0+1
    22  228a a114               		lda 	(eac,x)
    23  228c 8518               		sta 	temp0
    24  228e 209422             		jsr 	Divide
    25  2291 4c6121             		jmp 	execLoop
    26                          
    27                          ; *******************************************************************************************
    28                          ;
    29                          ;							register := register / temp0, mod in temp1
    30                          ;
    31                          ; *******************************************************************************************
    32                          
    33                          ;
    34                          ;	register = Q temp0 = M temp1 = A
    35                          ;
    36                          Divide:
    37  2294 a900               		lda 	#0 							; set A = 0
    38  2296 851a               		sta 	temp1
    39  2298 851b               		sta 	temp1+1
    40  229a a010               		ldy 	#16 						; loop round 16 times.
    41                          _DivLoop:
    42  229c 0612               		asl 	register 					; shift QA left. Q first
    43  229e 2613               		rol 	register+1
    44                          		;
    45  22a0 261a               		rol 	temp1 						; shift A left carrying in.
    46  22a2 261b               		rol 	temp1+1		
    47                          		;
    48  22a4 38                 		sec 								; calculate A-M, result in XA/C
    49  22a5 a51a               		lda 	temp1
    50  22a7 e518               		sbc 	temp0
    51  22a9 aa                 		tax
    52  22aa a51b               		lda 	temp1+1
    53  22ac e519               		sbc 	temp0+1
    54  22ae 9006               		bcc 	_DivNoUpdate 				; if A >= M then store result and set Q bit 0.
    55                          		;
    56  22b0 851b               		sta 	temp1+1
    57  22b2 861a               		stx 	temp1
    58  22b4 e612               		inc 	register 					; we know it is even.
    59                          		;
    60                          _DivNoUpdate:		
    61  22b6 88                 		dey
    62  22b7 d0e3               		bne 	_DivLoop
    63  22b9 60                 		rts

; ******** Source: main.asm
    88                          

; ******** Source: src\branch.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       branch.asm
     5                          ;      Purpose:    Branch commands
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;										9x BRA Branch Always
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          Command_BRA:
    19  22ba a517               		lda 	instr+1 					; needs sign extend.
    20  22bc 2908               		and 	#$08 						; if bit 11 is set.
    21  22be f006               		beq 	+
    22  22c0 a517               		lda 	instr+1
    23  22c2 09f0               		ora 	#$F0
    24  22c4 8517               		sta 	instr+1
    25                          +		
    26  22c6 18                 		clc 								; now add to the pctr
    27  22c7 a516               		lda 	instr
    28  22c9 6510               		adc 	pctr
    29  22cb 8510               		sta 	pctr
    30  22cd a517               		lda 	instr+1
    31  22cf 6511               		adc 	pctr+1
    32  22d1 8511               		sta 	pctr+1
    33                          
    34  22d3 4c6121             		jmp 	execLoop
    35                          
    36                          ; ***************************************************************************************************************
    37                          ;
    38                          ;										Ax BEQ Branch equal zero
    39                          ;
    40                          ; ***************************************************************************************************************
    41                          
    42                          Command_BEQ:
    43  22d6 a512               		lda 	register
    44  22d8 0513               		ora 	register+1
    45  22da f0de               		beq 	Command_BRA
    46  22dc 4c6121             		jmp 	execLoop
    47                          
    48                          ; ***************************************************************************************************************
    49                          ;
    50                          ;										Bx BPL Branch positive
    51                          ;
    52                          ; ***************************************************************************************************************
    53                          
    54                          Command_BPL:
    55  22df a513               		lda 	register+1
    56  22e1 10d7               		bpl 	Command_BRA
    57  22e3 4c6121             		jmp 	execLoop

; ******** Source: main.asm
    89                          

; ******** Source: src\call.asm
     1                          ; *******************************************************************************************
     2                          ; *******************************************************************************************
     3                          ;
     4                          ;       File:           call.asm
     5                          ;       Purpose:        Call and Return
     6                          ;      	Created:    	28th December 2020
     7                          ;       Author:         Paul Robson (paul@robson.org.uk)
     8                          ;
     9                          ; *******************************************************************************************
    10                          ; *******************************************************************************************
    11                          
    12                          ; *******************************************************************************************
    13                          ;
    14                          ;									CALL routine
    15                          ;
    16                          ; *******************************************************************************************
    17                          
    18                          Command_CALL:
    19  22e6 a510               		lda 	pctr 						; push PC on stack
    20  22e8 48                 		pha
    21  22e9 a511               		lda 	pctr+1
    22  22eb 48                 		pha
    23                          		;
    24  22ec 0616               		asl 	instr 						; instr x 4 => address
    25  22ee 2617               		rol 	instr+1
    26  22f0 0616               		asl 	instr
    27  22f2 2617               		rol 	instr+1
    28  22f4 a516               		lda 	instr 						; copy to vector
    29  22f6 8d9121             		sta 	vector
    30  22f9 a517               		lda 	instr+1
    31  22fb 8d9221             		sta 	vector+1
    32  22fe 200a23             		jsr 	_CCCallInstr 				; call that routine.
    33                          		;
    34  2301 68                 		pla 								; restore PC
    35  2302 8511               		sta 	pctr+1
    36  2304 68                 		pla
    37  2305 8510               		sta 	pctr
    38  2307 4c6121             		jmp 	execLoop 					; and go round
    39                          
    40                          _CCCallInstr:
    41  230a 6c9121             		jmp 	(vector)						
    42                          
    43                          ; *******************************************************************************************
    44                          ;
    45                          ;										Return Code
    46                          ;
    47                          ; *******************************************************************************************
    48                          
    49  230d 000000007379732e...		+define	"sys.return",0,0
    50                          ReturnCode:
    51  231c 68                 		pla 								; remove JSR to exec routine, call to return code.
    52  231d 68                 		pla
    53  231e 68                 		pla 		
    54  231f 68                 		pla
    55  2320 60                 		rts
    56                          
    57                          ; *******************************************************************************************
    58                          ;
    59                          ;										Halt Code
    60                          ;
    61                          ; *******************************************************************************************
    62                          
    63  2321 000000007379732e...		+define "sys.halt",0,0
    64                          HaltCode:		
    65  2330 a92a               		lda 	#42
    66  2332 204421             		jsr 	PrintCharacter
    67  2335 a2ee               		ldx 	#$EE
    68  2337 8a                 		txa
    69  2338 a8                 		tay
    70  2339 03                 		see
    71                          HaltNow:
    72  233a 4c3a23             		jmp 	HaltNow
    73                          
    74                          ; *******************************************************************************************
    75                          ;
    76                          ;											Print 
    77                          ;
    78                          ; *******************************************************************************************
    79                          
    80  233d 000001007379732e...		+define	"sys.print.hex",1,0
    81                          PrintHexCode:		
    82  2350 a513               		lda 	register+1
    83  2352 20ad23             		jsr 	PrintHex		
    84  2355 a512               		lda 	register
    85  2357 20ad23             		jsr 	PrintHex
    86  235a 60                 		rts
    87                          

; ******** Source: main.asm
    90                          

; ******** Source: src\utility.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       utility.asm
     5                          ;      Purpose:    Utility routines
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;											Erase data memory
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          ClearMemory:
    19  235b ad0c21             		lda 	initStart 					; start erasing from here
    20  235e 8518               		sta 	temp0
    21  2360 ad0d21             		lda 	initStart+1
    22  2363 8519               		sta 	temp0+1
    23  2365 a000               		ldy 	#0		
    24                          _CLMLoop:
    25  2367 a518               		lda 	temp0 						; done the lot ?
    26  2369 cd0e21             		cmp 	initEnd
    27  236c d008               		bne 	_CLMClear
    28  236e a519               		lda 	temp0+1
    29  2370 cd0f21             		cmp 	initEnd+1
    30  2373 d001               		bne 	_CLMClear
    31  2375 60                 		rts		
    32                          _CLMClear:
    33  2376 98                 		tya 								; zero location and advance.
    34  2377 9118               		sta 	(temp0),y
    35  2379 e618               		inc 	temp0
    36  237b d0ea               		bne 	_CLMLoop
    37  237d e619               		inc 	temp0+1
    38  237f 4c6723             		jmp 	_CLMLoop
    39                          
    40                          ; ***************************************************************************************************************
    41                          ;
    42                          ;										Show debug information
    43                          ;
    44                          ; ***************************************************************************************************************
    45                          
    46                          ShowDebugInfo:
    47  2382 a511               		lda 	pctr+1
    48  2384 20ad23             		jsr 	PrintHex
    49  2387 a510               		lda 	pctr
    50  2389 20ad23             		jsr 	PrintHex
    51  238c a517               		lda 	instr+1
    52  238e 20a623             		jsr 	PrintHexSpace
    53  2391 a516               		lda 	instr
    54  2393 20ad23             		jsr 	PrintHex
    55  2396 a513               		lda 	register+1
    56  2398 20a623             		jsr 	PrintHexSpace
    57  239b a512               		lda 	register
    58  239d 20ad23             		jsr 	PrintHex
    59  23a0 a93a               		lda 	#58
    60  23a2 204421             		jsr 	PrintCharacter
    61  23a5 60                 		rts		
    62                          
    63                          ; ***************************************************************************************************************
    64                          ;
    65                          ;						PrintA as hex constant with/without leading space
    66                          ;
    67                          ; ***************************************************************************************************************
    68                          
    69                          PrintHexSpace:
    70  23a6 48                 		pha
    71  23a7 a920               		lda 	#' '
    72  23a9 204421             		jsr 	PrintCharacter
    73  23ac 68                 		pla
    74                          PrintHex:        
    75  23ad 48                 		pha
    76  23ae 4a                 		lsr     
    77  23af 4a                 		lsr     
    78  23b0 4a                 		lsr     
    79  23b1 4a                 		lsr     
    80  23b2 20b623             		jsr     _PrintNibble
    81  23b5 68                 		pla
    82                          _PrintNibble:
    83  23b6 48                 		pha
    84  23b7 290f               		and     #15
    85  23b9 c90a               		cmp     #10
    86  23bb 9002               		bcc     +
    87  23bd 6906               		adc     #6
    88                          +
    89  23bf 6930               		adc     #48
    90  23c1 204421             		jsr     PrintCharacter
    91  23c4 68                 		pla 
    92  23c5 60                 		rts

; ******** Source: main.asm
    91                          
    92                          
    93                          ; ***************************************************************************************************************
    94                          ;
    95                          ;						Testing code goes here (this is for non runtime builds)
    96                          ;
    97                          ; ***************************************************************************************************************
    98                          
    99                          codeSpace:
   100  23c6 205621             		jsr 	execRuntime
   101  23c9 0001               		+cmd 	0,1
   102  23cb c8f6               		+call 	cs2
   103  23cd c8f6               		+call 	cs2
   104  23cf c8f6               		+call 	cs2
   105  23d1 c8d4               		+call 	PrintHexCode
   106  23d3 c8d4               		+call 	PrintHexCode
   107  23d5 c8cc               		+call	HaltCode
   108                          
   109  23d7 ea                 		!align 	3,0
   110                          cs2		
   111  23d8 205621             		jsr 	execRuntime
   112  23db 4002               		+cmd 	4,2
   113  23dd c8c7               		+call 	ReturnCode
   114                          
   115                          ; ***************************************************************************************************************
   116                          ;
   117                          ;					Then the variables with predefined values, constants, addresses etc.
   118                          ;
   119                          ; ***************************************************************************************************************
   120                          
   121  23df eaeaeaeaeaeaeaea...		!align 	255,0 						; put on page boundary.
   122                          SystemVariables:
   123  2400 1027               		!word 	10000
   124  2402 0200               		!word 	2
   125  2404 0a00               		!word 	10
   126                          
   127                          ; ***************************************************************************************************************
   128                          ;
   129                          ;									Then the uninitialised variables
   130                          ;
   131                          ; ***************************************************************************************************************
   132                          
   133                          UnnitialisedVariables:
   134                          		!if target > 0 { 					; allocate memory if not runtime build.
   135  2406 ffffffffffffffff...			!fill 	variableMax * 2,$FF
   136                          		}
   137                          EndVariableSpace:
