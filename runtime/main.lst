
; ******** Source: main.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       main.asm
     5                          ;      Purpose:    MTL Runtime (slow 'n' lazy version, NMOS 6502 only no optimisation)
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          zeroPageStart = $10                             ; zero page allocation here.
    13                          

; ******** Source: src\data.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       data.asm
     5                          ;      Purpose:    MTL Runtime ZP Allocation, Macros etc.
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          	
    12                          
    13                          ; ***************************************************************************************************************
    14                          ;
    15                          ;										Zero Page Allocation
    16                          ;
    17                          ; ***************************************************************************************************************
    18                          
    19                          pctr = zeroPageStart						; program counter (address of instruction)
    20                          
    21                          register = zeroPageStart+2 					; current register value.
    22                          
    23                          eac = zeroPageStart+4 						; effective address calculation.
    24                          
    25                          instr = zeroPageStart+6 					; current instruction.
    26                          
    27                          temp0 = zeroPageStart+8 					; working registers.
    28                          
    29                          temp1 = zeroPageStart+10 
    30                          
    31                          nextFreeZero = zeroPageStart + 16 			; memory we can use.
    32                          
    33                          ; ***************************************************************************************************************
    34                          ;
    35                          ;												Macros
    36                          ;
    37                          ; ***************************************************************************************************************
    38                          
    39                          !macro set16 .addr,.value {
    40                          		lda 	#((.value) & $FF)
    41                          		sta 	0+(.addr)
    42                          		lda 	#((.value) >> 8)
    43                          		sta 	1+(.addr)	
    44                          }
    45                          
    46                          !macro 	inc16 .addr {
    47                          		inc 	0+(.addr)
    48                          		bne 	+
    49                          		inc 	1+(.addr)
    50                          +
    51                          }
    52                          
    53                          !macro cmd 	.cmdid,.addr {
    54                          		!byte 	(.cmdid << 4)+((.addr >> 8) & 0x0F)
    55                          		!byte 	(.addr & $FF)
    56                          }		
    57                          
    58                          !macro call .addr {
    59                          		!byte 	((.addr >> 10) & $3F)+$C0
    60                          		!byte 	(.addr >> 2) & $FF		
    61                          }
    62                          
    63                          !macro define .name,.count,.first {
    64                          		!word 	0 							; link to next (filled in later)
    65                          		!byte 	.count 						; number of parameters
    66                          		!byte 	.first 						; first parameter address if more than one (last in R)
    67                          		!text 	.name,0 					; ASCIIZ name.
    68                          		!align 	3,0 

; ******** Source: main.asm
    14                          
    15                          
    16                          ; ***************************************************************************************************************
    17                          ;
    18                          ;					Runtime Header starts here (if not run in test handler, target #0)
    19                          ;
    20                          ; ***************************************************************************************************************
    21                          
    22                          start
    23  2100 4c4021             		jmp 	boot 						; +0  is jump to initial code
    24  2103 00                 		!byte 	0
    25                          execRoutine		
    26  2104 4cb521             		jmp 	execRuntime 				; +4  is opcode execution routine
    27  2107 00                 		!byte 	0
    28                          
    29                          firstProcedure		
    30  2108 2624               		!word	codeSpace 					; +8  is the address of the first procedure.
    31                          
    32                          loadAddress		
    33  210a 0021               		!word 	start  						; +10 is the load address
    34                          
    35                          initStart
    36  210c 0625               		!word 	UnnitialisedVariables 		; +12 is the start of the uninitialised variables.
    37                          
    38                          initEnd
    39  210e 4625               		!word 	EndVariableSpace 			; +14 is the end of the uninitialised variables.
    40                          
    41                          registerAddress
    42  2110 1200               		!word 	register					; +16 is the address of the register
    43                          
    44                          nextFreeZeroAddress 	 						
    45  2112 2000               		!word 	nextFreeZero				; +18 next free zp address.
    46                          
    47                          routineList 								
    48  2114 0000               		!word 	0							; +20 linked list of routines built in/library.
    49                          
    50                          		* = start+64
    51                          
    52                          ; ***************************************************************************************************************
    53                          ;
    54                          ;								Import the system specific code
    55                          ;
    56                          ; ***************************************************************************************************************
    57                          
    58                          		!if target=1 {

; ******** Source: src\bootmega.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       bootmega.asm
     5                          ;      Purpose:    MTL Runtime, specific Mega65 code
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          myTemp4 = $02                                   ; temp far pointer
    13                          variableMax = 32 								; how many variables allowed in test version
    14                          
    15                          ; ***************************************************************************************************************
    16                          ;
    17                          ;                                               Header, a BASIC line
    18                          ;
    19                          ; ***************************************************************************************************************
    20                          
    21                          boot						
    22  2140 78                 	sei                                     ; disable Interrupts
    23  2141 a935               	lda     #$35                            ; C64 RAM visibility/tape off. 
    24  2143 8501               	sta     $01
    25                          
    26  2145 a900               	lda     #$00                            ; Reset mapping - lower/upper offsets = 0
    27  2147 aa                 	tax                                     ; so everything except $Dxxx RAM ?
    28  2148 a8                 	tay 
    29  2149 4b                 	taz 
    30  214a 5c                 	map
    31  214b ea                 	eom
    32                          
    33  214c a9fe               	lda     #$FE                            ; use page $FExx as ZP.
    34  214e 5b                 	tab
    35  214f 4ca621             	jmp     runApplication
    36                          
    37                          ; ***************************************************************************************************************
    38                          ;
    39                          ;                                               Print Character A
    40                          ;
    41                          ; ***************************************************************************************************************
    42                          
    43                          PrintCharacter
    44  2152 48                 	pha
    45  2153 da                 	phx
    46  2154 5a                 	phy
    47  2155 db                 	phz
    48                          
    49  2156 293f               	and     #63                             ; handle PETSCII
    50  2158 48                 	pha
    51                          
    52  2159 ada421             	lda 	charPos
    53  215c 8502               	sta 	myTemp4
    54  215e ada521             	lda 	charPos+1
    55  2161 18                 	clc
    56  2162 6908               	adc 	#$08
    57  2164 8503               	sta 	myTemp4+1
    58  2166 68                 	pla
    59  2167 a000               	ldy 	#0
    60  2169 9102               	sta 	(myTemp4),y
    61                          
    62                          				                            ; write colour to $01F800 (Color RAM)
    63  216b 18                 	clc
    64  216c ada521             	lda 	charPos+1
    65  216f 69f8               	adc 	#$F8
    66  2171 8503               	sta     myTemp4+1
    67  2173 a901               	lda     #$01
    68  2175 8504               	sta     myTemp4+2
    69  2177 a900               	lda     #$00
    70  2179 4b                 	taz
    71  217a 8505               	sta     myTemp4+3
    72  217c a901               	lda     #$01
    73  217e ea9202             	sta     [myTemp4],z
    74                          
    75  2181 eea421             	inc 	charPos
    76  2184 d003               	bne 	_PCNoCarry
    77  2186 eea521             	inc 	charPos+1
    78                          _PCNoCarry
    79  2189 ada421             	lda 	charPos
    80  218c c9d0               	cmp 	#$D0
    81  218e d00f               	bne 	_PCExit
    82  2190 ada521             	lda 	charPos+1
    83  2193 c907               	cmp 	#7
    84  2195 d008               	bne 	_PCExit
    85                          
    86                          
    87  2197 a900               	lda 	#0
    88  2199 8da421             	sta 	charPos
    89  219c 8da521             	sta 	charPos+1
    90                          _PCExit:	
    91  219f fb                 	plz
    92  21a0 7a                 	ply
    93  21a1 fa                 	plx
    94  21a2 68                 	pla
    95  21a3 60                 	rts
    96                          
    97                          charPos
    98  21a4 0000               	!word 	0
    99                          

; ******** Source: main.asm
    59                          
    60                          		} 
    61                          		!if target=2 {
    62                          		!source "src/boottest.asm"
    63                          		}
    64                          
    65                          ; ***************************************************************************************************************
    66                          ;
    67                          ;									Runtime code starts here
    68                          ;
    69                          ; ***************************************************************************************************************
    70                          
    71                          runApplication		
    72  21a6 a2ff               		ldx 	#$FF 						; reset the 6502 stack.
    73  21a8 9a                 		txs
    74  21a9 20bb23             		jsr 	ClearMemory 				; erase all memory.
    75  21ac 20b221             		jsr 	runFirstProc 				; run the first procedure
    76  21af 4caf21             halted:	jmp 	halted		 				; and stop.
    77                          
    78                          runFirstProc		
    79  21b2 6c0821             		jmp 	(firstProcedure) 			; execute the first procedure
    80                          
    81                          ; ***************************************************************************************************************
    82                          ;
    83                          ;											Includes
    84                          ;
    85                          ; ***************************************************************************************************************
    86                          

; ******** Source: src\exec.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       exec.asm
     5                          ;      Purpose:    Execute the runtime
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;									Run a code routine following the call
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          execRuntime
    19  21b5 18                 		clc
    20  21b6 68                 		pla 								; get the start address from the call + 1
    21  21b7 6901               		adc 	#1 							; RTS post increments on return.
    22  21b9 8510               		sta 	pctr
    23  21bb 68                 		pla
    24  21bc 6900               		adc 	#0
    25  21be 8511               		sta 	pctr+1
    26                          
    27                          execLoop
    28  21c0 a000               		ldy 	#0 							; get instruction (Hi/Lo order)
    29  21c2 b110               		lda 	(pctr),y
    30  21c4 8517               		sta 	instr+1
    31  21c6 c8                 		iny
    32  21c7 b110               		lda 	(pctr),y
    33  21c9 8516               		sta 	instr
    34                          		;
    35  21cb 20e223             		jsr 	ShowDebugInfo 				; current state if debugging
    36                          		;
    37  21ce a510               		lda 	pctr 						; bump pctr
    38  21d0 18                 		clc 
    39  21d1 6902               		adc 	#2
    40  21d3 8510               		sta 	pctr
    41  21d5 9002               		bcc 	+
    42  21d7 e611               		inc 	pctr+1
    43                          +
    44  21d9 a517               		lda 	instr+1 					; get instr MSN and double it, so shift right thrice.
    45  21db 4a                 		lsr
    46  21dc 4a                 		lsr
    47  21dd 4a                 		lsr
    48  21de 291e               		and 	#$1E 						; force into range
    49  21e0 aa                 		tax
    50                          
    51  21e1 bdf221             		lda 	execTable,x 				; get address and go there.
    52  21e4 8df021             		sta 	vector
    53  21e7 bdf321             		lda 	execTable+1,x
    54  21ea 8df121             		sta 	vector+1
    55  21ed 6cf021             		jmp 	(vector)
    56                          
    57                          vector 										; cannot go in ZP if we move B
    58  21f0 0000               		!word 	0
    59                          
    60                          execTable
    61  21f2 1a22               		!word 	Command_LDR  				; $0x Load Register
    62  21f4 2822               		!word 	Command_STR  				; $1x Store Register
    63  21f6 3622               		!word 	Command_ADD 				; $2x Add to Register
    64  21f8 4922               		!word 	Command_SUB 				; $3x Sub from Register
    65  21fa a522               		!word 	Command_MUL 				; $4x Multiply into Register
    66  21fc e222               		!word 	Command_DIV 				; $5x Divide into Register
    67  21fe 5c22               		!word 	Command_AND 				; $6x And into Register
    68  2200 6e22               		!word 	Command_ORR 				; $7x Or with Register
    69  2202 8022               		!word 	Command_XOR 				; $8x Xor into Register
    70  2204 1923               		!word 	Command_BRA 				; $9x Branch always
    71  2206 3523               		!word 	Command_BEQ 				; $Ax Branch zero
    72  2208 3e23               		!word 	Command_BPL 				; $Bx Branch positive
    73  220a 4523               		!word 	Command_CALL 				; $Cx Call 6502 routine
    74  220c 4523               		!word 	Command_CALL 				; $Dx Call 6502 routine
    75  220e 4523               		!word 	Command_CALL 				; $Ex Call 6502 routine
    76  2210 4523               		!word 	Command_CALL 				; $Fx Call 6502 routine
    77                          
    78                          notImplemented								; come here when not implemented.
    79  2212 a2ee               		ldx 	#$EE
    80  2214 8a                 		txa
    81  2215 a8                 		tay
    82  2216 03                 		see
    83                          halt

; ******** Source: main.asm
    87  2217 4c1722             

; ******** Source: src\simple.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       simple.asm
     5                          ;      Purpose:    Simple Opcodes
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;										0x LDR - Load Register
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          Command_LDR:
    19  221a 209222             		jsr 	EffectiveAddress
    20  221d b114               		lda 	(eac),y
    21  221f 8513               		sta 	register+1
    22  2221 a114               		lda 	(eac,x)
    23  2223 8512               		sta 	register		
    24  2225 4cc021             		jmp 	execLoop
    25                          
    26                          ; ***************************************************************************************************************
    27                          ;
    28                          ;										1x STR - Store Register
    29                          ;
    30                          ; ***************************************************************************************************************
    31                          
    32                          Command_STR:
    33  2228 209222             		jsr 	EffectiveAddress
    34  222b a513               		lda 	register+1
    35  222d 9114               		sta 	(eac),y
    36  222f a512               		lda 	register		
    37  2231 8114               		sta 	(eac,x)
    38  2233 4cc021             		jmp 	execLoop
    39                          
    40                          ; ***************************************************************************************************************
    41                          ;
    42                          ;										2x ADD - Add Register
    43                          ;
    44                          ; ***************************************************************************************************************
    45                          
    46                          Command_ADD:
    47  2236 209222             		jsr 	EffectiveAddress
    48  2239 18                 		clc
    49  223a a512               		lda 	register		
    50  223c 6114               		adc 	(eac,x)
    51  223e 8512               		sta 	register
    52  2240 a513               		lda 	register+1
    53  2242 7114               		adc 	(eac),y
    54  2244 8513               		sta		register+1
    55  2246 4cc021             		jmp 	execLoop
    56                          
    57                          ; ***************************************************************************************************************
    58                          ;
    59                          ;										3x SUB - Sub from Register
    60                          ;
    61                          ; ***************************************************************************************************************
    62                          
    63                          Command_SUB:
    64  2249 209222             		jsr 	EffectiveAddress
    65  224c 38                 		sec
    66  224d a512               		lda 	register		
    67  224f e114               		sbc 	(eac,x)
    68  2251 8512               		sta 	register
    69  2253 a513               		lda 	register+1
    70  2255 f114               		sbc 	(eac),y
    71  2257 8513               		sta		register+1
    72  2259 4cc021             		jmp 	execLoop
    73                          
    74                          ; ***************************************************************************************************************
    75                          ;
    76                          ;										6x AND - And Register
    77                          ;
    78                          ; ***************************************************************************************************************
    79                          
    80                          Command_AND:
    81  225c 209222             		jsr 	EffectiveAddress
    82  225f a512               		lda 	register		
    83  2261 2114               		and 	(eac,x)
    84  2263 8512               		sta 	register
    85  2265 a513               		lda 	register+1
    86  2267 3114               		and 	(eac),y
    87  2269 8513               		sta		register+1
    88  226b 4cc021             		jmp 	execLoop
    89                          
    90                          ; ***************************************************************************************************************
    91                          ;
    92                          ;										7x ORR - Or Register
    93                          ;
    94                          ; ***************************************************************************************************************
    95                          
    96                          Command_ORR:
    97  226e 209222             		jsr 	EffectiveAddress
    98  2271 a512               		lda 	register		
    99  2273 0114               		ora 	(eac,x)
   100  2275 8512               		sta 	register
   101  2277 a513               		lda 	register+1
   102  2279 1114               		ora 	(eac),y
   103  227b 8513               		sta		register+1
   104  227d 4cc021             		jmp 	execLoop
   105                          
   106                          ; ***************************************************************************************************************
   107                          ;
   108                          ;										8x XOR - ExOr Register
   109                          ;
   110                          ; ***************************************************************************************************************
   111                          
   112                          Command_XOR:
   113  2280 209222             		jsr 	EffectiveAddress
   114  2283 a512               		lda 	register		
   115  2285 4114               		eor 	(eac,x)
   116  2287 8512               		sta 	register
   117  2289 a513               		lda 	register+1
   118  228b 5114               		eor 	(eac),y
   119  228d 8513               		sta		register+1
   120  228f 4cc021             		jmp 	execLoop
   121                          
   122                          ; ***************************************************************************************************************
   123                          ;
   124                          ;						Effective address calc on instruction, set X = 0 Y = 1
   125                          ;
   126                          ; ***************************************************************************************************************
   127                          
   128                          EffectiveAddress:
   129  2292 a516               		lda 	instr
   130  2294 0a                 		asl 	
   131  2295 8514               		sta 	eac
   132  2297 a517               		lda 	instr+1
   133  2299 290f               		and 	#$0F
   134  229b 2a                 		rol 	
   135  229c 6925               		adc 	#SystemVariables >> 8
   136  229e 8515               		sta 	eac+1
   137  22a0 a001               		ldy 	#1
   138  22a2 a200               		ldx 	#0

; ******** Source: main.asm
    88  22a4 60                 

; ******** Source: src\multiply.asm
     1                          ; *******************************************************************************************
     2                          ; *******************************************************************************************
     3                          ;
     4                          ;       File:           multiply.asm
     5                          ;       Purpose:        Multiply code
     6                          ;      	Created:    	27th December 2020
     7                          ;       Author:         Paul Robson (paul@robson.org.uk)
     8                          ;
     9                          ; *******************************************************************************************
    10                          ; *******************************************************************************************
    11                          
    12                          ; *******************************************************************************************
    13                          ;
    14                          ;							4x MUL - Multiply into register
    15                          ;
    16                          ; *******************************************************************************************
    17                          
    18                          Command_MUL:
    19  22a5 209222             		jsr 	EffectiveAddress 			; but value into temp1
    20  22a8 b114               		lda 	(eac),y
    21  22aa 851b               		sta 	temp1+1
    22  22ac a114               		lda 	(eac,x)
    23  22ae 851a               		sta 	temp1
    24  22b0 a512               		lda 	register 					; register into temp0 and multiply.
    25  22b2 8518               		sta 	temp0
    26  22b4 a513               		lda 	register+1
    27  22b6 8519               		sta 	temp0+1
    28  22b8 20be22             		jsr 	Multiply
    29  22bb 4cc021             		jmp 	execLoop
    30                          
    31                          ; *******************************************************************************************
    32                          ;
    33                          ;								register := temp0 * temp1
    34                          ;
    35                          ; *******************************************************************************************
    36                          
    37                          Multiply:
    38  22be a900               		lda 	#0 							; zero total.
    39  22c0 8512               		sta 	register
    40  22c2 8513               		sta 	register+1
    41                          _MultLoop:
    42  22c4 4619               		lsr 	temp0+1
    43  22c6 6618               		ror 	temp0	
    44  22c8 900d               		bcc 	_MultNoAdd
    45  22ca 18                 		clc
    46  22cb a51a               		lda 	temp1		
    47  22cd 6512               		adc 	register
    48  22cf 8512               		sta 	register
    49  22d1 a51b               		lda 	temp1+1
    50  22d3 6513               		adc 	register+1
    51  22d5 8513               		sta 	register+1
    52                          _MultNoAdd:
    53  22d7 061a               		asl 	temp1
    54  22d9 261b               		rol 	temp1+1
    55  22db a518               		lda 	temp0
    56  22dd 0519               		ora 	temp0+1
    57  22df d0e3               		bne 	_MultLoop
    58  22e1 60                 		rts

; ******** Source: main.asm
    89                          

; ******** Source: src\divide.asm
     1                          ; *******************************************************************************************
     2                          ; *******************************************************************************************
     3                          ;
     4                          ;       File:           divide.asm
     5                          ;       Purpose:        Divide and Modulus code
     6                          ;      	Created:    	27th December 2020
     7                          ;       Author:         Paul Robson (paul@robson.org.uk)
     8                          ;
     9                          ; *******************************************************************************************
    10                          ; *******************************************************************************************
    11                          
    12                          ; *******************************************************************************************
    13                          ;
    14                          ;							5x DIV - Divide into register
    15                          ;
    16                          ; *******************************************************************************************
    17                          
    18                          Command_DIV:
    19  22e2 209222             		jsr 	EffectiveAddress 			; but value into temp1
    20  22e5 b114               		lda 	(eac),y
    21  22e7 8519               		sta 	temp0+1
    22  22e9 a114               		lda 	(eac,x)
    23  22eb 8518               		sta 	temp0
    24  22ed 20f322             		jsr 	Divide
    25  22f0 4cc021             		jmp 	execLoop
    26                          
    27                          ; *******************************************************************************************
    28                          ;
    29                          ;							register := register / temp0, mod in temp1
    30                          ;
    31                          ; *******************************************************************************************
    32                          
    33                          ;
    34                          ;	register = Q temp0 = M temp1 = A
    35                          ;
    36                          Divide:
    37  22f3 a900               		lda 	#0 							; set A = 0
    38  22f5 851a               		sta 	temp1
    39  22f7 851b               		sta 	temp1+1
    40  22f9 a010               		ldy 	#16 						; loop round 16 times.
    41                          _DivLoop:
    42  22fb 0612               		asl 	register 					; shift QA left. Q first
    43  22fd 2613               		rol 	register+1
    44                          		;
    45  22ff 261a               		rol 	temp1 						; shift A left carrying in.
    46  2301 261b               		rol 	temp1+1		
    47                          		;
    48  2303 38                 		sec 								; calculate A-M, result in XA/C
    49  2304 a51a               		lda 	temp1
    50  2306 e518               		sbc 	temp0
    51  2308 aa                 		tax
    52  2309 a51b               		lda 	temp1+1
    53  230b e519               		sbc 	temp0+1
    54  230d 9006               		bcc 	_DivNoUpdate 				; if A >= M then store result and set Q bit 0.
    55                          		;
    56  230f 851b               		sta 	temp1+1
    57  2311 861a               		stx 	temp1
    58  2313 e612               		inc 	register 					; we know it is even.
    59                          		;
    60                          _DivNoUpdate:		
    61  2315 88                 		dey
    62  2316 d0e3               		bne 	_DivLoop
    63  2318 60                 		rts

; ******** Source: main.asm
    90                          

; ******** Source: src\branch.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       branch.asm
     5                          ;      Purpose:    Branch commands
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;										9x BRA Branch Always
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          Command_BRA:
    19  2319 a517               		lda 	instr+1 					; needs sign extend.
    20  231b 2908               		and 	#$08 						; if bit 11 is set.
    21  231d f006               		beq 	+
    22  231f a517               		lda 	instr+1
    23  2321 09f0               		ora 	#$F0
    24  2323 8517               		sta 	instr+1
    25                          +		
    26  2325 18                 		clc 								; now add to the pctr
    27  2326 a516               		lda 	instr
    28  2328 6510               		adc 	pctr
    29  232a 8510               		sta 	pctr
    30  232c a517               		lda 	instr+1
    31  232e 6511               		adc 	pctr+1
    32  2330 8511               		sta 	pctr+1
    33                          
    34  2332 4cc021             		jmp 	execLoop
    35                          
    36                          ; ***************************************************************************************************************
    37                          ;
    38                          ;										Ax BEQ Branch equal zero
    39                          ;
    40                          ; ***************************************************************************************************************
    41                          
    42                          Command_BEQ:
    43  2335 a512               		lda 	register
    44  2337 0513               		ora 	register+1
    45  2339 f0de               		beq 	Command_BRA
    46  233b 4cc021             		jmp 	execLoop
    47                          
    48                          ; ***************************************************************************************************************
    49                          ;
    50                          ;										Bx BPL Branch positive
    51                          ;
    52                          ; ***************************************************************************************************************
    53                          
    54                          Command_BPL:
    55  233e a513               		lda 	register+1
    56  2340 10d7               		bpl 	Command_BRA
    57  2342 4cc021             		jmp 	execLoop

; ******** Source: main.asm
    91                          

; ******** Source: src\call.asm
     1                          ; *******************************************************************************************
     2                          ; *******************************************************************************************
     3                          ;
     4                          ;       File:           call.asm
     5                          ;       Purpose:        Call and Return
     6                          ;      	Created:    	28th December 2020
     7                          ;       Author:         Paul Robson (paul@robson.org.uk)
     8                          ;
     9                          ; *******************************************************************************************
    10                          ; *******************************************************************************************
    11                          
    12                          ; *******************************************************************************************
    13                          ;
    14                          ;									CALL routine
    15                          ;
    16                          ; *******************************************************************************************
    17                          
    18                          Command_CALL:
    19  2345 a510               		lda 	pctr 						; push PC on stack
    20  2347 48                 		pha
    21  2348 a511               		lda 	pctr+1
    22  234a 48                 		pha
    23                          		;
    24  234b 0616               		asl 	instr 						; instr x 4 => address
    25  234d 2617               		rol 	instr+1
    26  234f 0616               		asl 	instr
    27  2351 2617               		rol 	instr+1
    28  2353 a516               		lda 	instr 						; copy to vector
    29  2355 8df021             		sta 	vector
    30  2358 a517               		lda 	instr+1
    31  235a 8df121             		sta 	vector+1
    32  235d 206923             		jsr 	_CCCallInstr 				; call that routine.
    33                          		;
    34  2360 68                 		pla 								; restore PC
    35  2361 8511               		sta 	pctr+1
    36  2363 68                 		pla
    37  2364 8510               		sta 	pctr
    38  2366 4cc021             		jmp 	execLoop 					; and go round
    39                          
    40                          _CCCallInstr:
    41  2369 6cf021             		jmp 	(vector)						
    42                          
    43                          ; *******************************************************************************************
    44                          ;
    45                          ;										Return Code
    46                          ;
    47                          ; *******************************************************************************************
    48                          
    49  236c 000000007379732e...		+define	"sys.return",0,0
    50                          ReturnCode:
    51  237c 68                 		pla 								; remove JSR to exec routine, call to return code.
    52  237d 68                 		pla
    53  237e 68                 		pla 		
    54  237f 68                 		pla
    55  2380 60                 		rts
    56                          
    57                          ; *******************************************************************************************
    58                          ;
    59                          ;										Halt Code
    60                          ;
    61                          ; *******************************************************************************************
    62                          
    63  2381 000000007379732e...		+define "sys.halt",0,0
    64                          HaltCode:		
    65  2390 a92a               		lda 	#42
    66  2392 205221             		jsr 	PrintCharacter
    67  2395 a2ee               		ldx 	#$EE
    68  2397 8a                 		txa
    69  2398 a8                 		tay
    70  2399 03                 		see
    71                          HaltNow:
    72  239a 4c9a23             		jmp 	HaltNow
    73                          
    74                          ; *******************************************************************************************
    75                          ;
    76                          ;											Print 
    77                          ;
    78                          ; *******************************************************************************************
    79                          
    80  239d 000001007379732e...		+define	"sys.print.hex",1,0
    81                          PrintHexCode:		
    82  23b0 a513               		lda 	register+1
    83  23b2 200d24             		jsr 	PrintHex		
    84  23b5 a512               		lda 	register
    85  23b7 200d24             		jsr 	PrintHex
    86  23ba 60                 		rts
    87                          

; ******** Source: main.asm
    92                          

; ******** Source: src\utility.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       utility.asm
     5                          ;      Purpose:    Utility routines
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;											Erase data memory
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          ClearMemory:
    19  23bb ad0c21             		lda 	initStart 					; start erasing from here
    20  23be 8518               		sta 	temp0
    21  23c0 ad0d21             		lda 	initStart+1
    22  23c3 8519               		sta 	temp0+1
    23  23c5 a000               		ldy 	#0		
    24                          _CLMLoop:
    25  23c7 a518               		lda 	temp0 						; done the lot ?
    26  23c9 cd0e21             		cmp 	initEnd
    27  23cc d008               		bne 	_CLMClear
    28  23ce a519               		lda 	temp0+1
    29  23d0 cd0f21             		cmp 	initEnd+1
    30  23d3 d001               		bne 	_CLMClear
    31  23d5 60                 		rts		
    32                          _CLMClear:
    33  23d6 98                 		tya 								; zero location and advance.
    34  23d7 9118               		sta 	(temp0),y
    35  23d9 e618               		inc 	temp0
    36  23db d0ea               		bne 	_CLMLoop
    37  23dd e619               		inc 	temp0+1
    38  23df 4cc723             		jmp 	_CLMLoop
    39                          
    40                          ; ***************************************************************************************************************
    41                          ;
    42                          ;										Show debug information
    43                          ;
    44                          ; ***************************************************************************************************************
    45                          
    46                          ShowDebugInfo:
    47  23e2 a511               		lda 	pctr+1
    48  23e4 200d24             		jsr 	PrintHex
    49  23e7 a510               		lda 	pctr
    50  23e9 200d24             		jsr 	PrintHex
    51  23ec a517               		lda 	instr+1
    52  23ee 200624             		jsr 	PrintHexSpace
    53  23f1 a516               		lda 	instr
    54  23f3 200d24             		jsr 	PrintHex
    55  23f6 a513               		lda 	register+1
    56  23f8 200624             		jsr 	PrintHexSpace
    57  23fb a512               		lda 	register
    58  23fd 200d24             		jsr 	PrintHex
    59  2400 a93a               		lda 	#58
    60  2402 205221             		jsr 	PrintCharacter
    61  2405 60                 		rts		
    62                          
    63                          ; ***************************************************************************************************************
    64                          ;
    65                          ;						PrintA as hex constant with/without leading space
    66                          ;
    67                          ; ***************************************************************************************************************
    68                          
    69                          PrintHexSpace:
    70  2406 48                 		pha
    71  2407 a920               		lda 	#' '
    72  2409 205221             		jsr 	PrintCharacter
    73  240c 68                 		pla
    74                          PrintHex:        
    75  240d 48                 		pha
    76  240e 4a                 		lsr     
    77  240f 4a                 		lsr     
    78  2410 4a                 		lsr     
    79  2411 4a                 		lsr     
    80  2412 201624             		jsr     _PrintNibble
    81  2415 68                 		pla
    82                          _PrintNibble:
    83  2416 48                 		pha
    84  2417 290f               		and     #15
    85  2419 c90a               		cmp     #10
    86  241b 9002               		bcc     +
    87  241d 6906               		adc     #6
    88                          +
    89  241f 6930               		adc     #48
    90  2421 205221             		jsr     PrintCharacter
    91  2424 68                 		pla 
    92  2425 60                 		rts

; ******** Source: main.asm
    93                          
    94                          
    95                          ; ***************************************************************************************************************
    96                          ;
    97                          ;						Testing code goes here (this is for non runtime builds)
    98                          ;
    99                          ; ***************************************************************************************************************
   100                          
   101                          codeSpace:
   102  2426 20b521             		jsr 	execRuntime
   103  2429 0001               		+cmd 	0,1
   104  242b c90e               		+call 	cs2
   105  242d c90e               		+call 	cs2
   106  242f c90e               		+call 	cs2
   107  2431 c8ec               		+call 	PrintHexCode
   108  2433 c8ec               		+call 	PrintHexCode
   109  2435 c8e4               		+call	HaltCode
   110                          
   111  2437 ea                 		!align 	3,0
   112                          cs2		
   113  2438 20b521             		jsr 	execRuntime
   114  243b 4002               		+cmd 	4,2
   115  243d c8df               		+call 	ReturnCode
   116                          
   117                          ; ***************************************************************************************************************
   118                          ;
   119                          ;					Then the variables with predefined values, constants, addresses etc.
   120                          ;
   121                          ; ***************************************************************************************************************
   122                          
   123  243f eaeaeaeaeaeaeaea...		!align 	255,0 						; put on page boundary.
   124                          SystemVariables:
   125  2500 1027               		!word 	10000
   126  2502 0200               		!word 	2
   127  2504 0a00               		!word 	10
   128                          
   129                          ; ***************************************************************************************************************
   130                          ;
   131                          ;									Then the uninitialised variables
   132                          ;
   133                          ; ***************************************************************************************************************
   134                          
   135                          UnnitialisedVariables:
   136                          		!if target > 0 { 					; allocate memory if not runtime build.
   137  2506 ffffffffffffffff...			!fill 	variableMax * 2,$FF
   138                          		}
   139                          EndVariableSpace:
