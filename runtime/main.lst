
; ******** Source: main.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       main.asm
     5                          ;      Purpose:    MTL Runtime (slow 'n' lazy version, NMOS 6502 only no optimisation)
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          
    13                          ; ***************************************************************************************************************
    14                          ;
    15                          ;					Runtime Header starts here (if not run in test handler, target #0)
    16                          ;
    17                          ; ***************************************************************************************************************
    18                          
    19                          start
    20  2100 4c4021             		jmp 	boot 						; +0  is jump to initial code
    21  2103 00                 		!byte 	0
    22                          execRoutine		
    23  2104 4c5621             		jmp 	execRuntime 				; +4  is opcode execution routine
    24  2107 00                 		!byte 	0
    25                          
    26                          firstProcedure		
    27  2108 1b22               		!word	codeSpace 					; +8  is the address of the first procedure.
    28                          loadAddress		
    29  210a 0021               		!word 	start  						; +10 is the load address
    30                          initStart
    31  210c 0423               		!word 	UnnitialisedVariables 		; +12 is the start of the uninitialised variables.
    32                          initEnd
    33  210e 4423               		!word 	EndVariableSpace 			; +14 is the end of the uninitialised variables.
    34                          
    35                          		* = start+64
    36                          
    37                          ; ***************************************************************************************************************
    38                          ;
    39                          ;								Import the system specific code
    40                          ;
    41                          ; ***************************************************************************************************************
    42                          
    43                          		!if target=1 {
    44                          		!source "bootmega.asm"
    45                          		} 
    46                          		!if target=2 {

; ******** Source: boottest.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       boottest.asm
     5                          ;      Purpose:    MTL Runtime, testbed code.
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          zeroPageStart = $10
    13                          
    14                          variableMax = 32 								; how many variables allowed in test version
    15                          
    16                          boot
    17  2140 78                 		sei
    18  2141 4c4721             		jmp     runApplication
    19                          
    20                          ; ***************************************************************************************************************
    21                          ;
    22                          ;											Print Character in A
    23                          ;
    24                          ; ***************************************************************************************************************
    25                          
    26                          PrintCharacter
    27  2144 4ceeff             		jmp     $FFEE

; ******** Source: main.asm
    48                          		}

; ******** Source: data.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       data.asm
     5                          ;      Purpose:    MTL Runtime ZP Allocation, Macros etc.
     6                          ;      Created:    26th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          	
    12                          
    13                          ; ***************************************************************************************************************
    14                          ;
    15                          ;										Zero Page Allocation
    16                          ;
    17                          ; ***************************************************************************************************************
    18                          
    19                          pctr = zeroPageStart						; program counter (address of instruction)
    20                          
    21                          register = zeroPageStart+2 					; current register value.
    22                          
    23                          eac = zeroPageStart+4 						; effective address calculation.
    24                          
    25                          instr = zeroPageStart+6 					; current instruction.
    26                          
    27                          temp0 = zeroPageStart+8 					; target address.
    28                          
    29                          ; ***************************************************************************************************************
    30                          ;
    31                          ;												Macros
    32                          ;
    33                          ; ***************************************************************************************************************
    34                          
    35                          !macro set16 .addr,.value {
    36                          		lda 	#((.value) & $FF)
    37                          		sta 	0+(.addr)
    38                          		lda 	#((.value) >> 8)
    39                          		sta 	1+(.addr)
    40                          }
    41                          
    42                          !macro 	inc16 .addr {
    43                          		inc 	0+(.addr)
    44                          		bne 	+
    45                          		inc 	1+(.addr)
    46                          +
    47                          }
    48                          
    49                          !macro cmd 	.cmdid,.addr {
    50                          		!byte 	(.cmdid << 4)+((.addr >> 8) & 0x0F)
    51                          		!byte 	(.addr & $FF)
    52                          }		
    53                          

; ******** Source: main.asm
    50                          
    51                          ; ***************************************************************************************************************
    52                          ;
    53                          ;									Runtime code starts here
    54                          ;
    55                          ; ***************************************************************************************************************
    56                          
    57                          runApplication		
    58  2147 a2ff               		ldx 	#$FF 						; reset the 6502 stack.
    59  2149 9a                 		txs
    60  214a 20b521             		jsr 	ClearMemory 				; erase all memory.
    61  214d 205321             		jsr 	runFirstProc 				; run the first procedure
    62  2150 4c5021             halted:	jmp 	halted		 				; and stop.
    63                          
    64                          runFirstProc		
    65  2153 6c0821             		jmp 	(firstProcedure) 			; execute the first procedure
    66                          
    67                          ; ***************************************************************************************************************
    68                          ;
    69                          ;											Includes
    70                          ;
    71                          ; ***************************************************************************************************************
    72                          

; ******** Source: exec.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       exec.asm
     5                          ;      Purpose:    Execute the runtime
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;									Run a code routine following the call
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          execRuntime
    19  2156 18                 		clc
    20  2157 68                 		pla 								; get the start address from the call + 1
    21  2158 6901               		adc 	#1 							; RTS post increments on return.
    22  215a 8510               		sta 	pctr
    23  215c 68                 		pla
    24  215d 6900               		adc 	#0
    25  215f 8511               		sta 	pctr+1
    26                          
    27                          execLoop
    28  2161 a000               		ldy 	#0 							; get instruction (Hi/Lo order)
    29  2163 b110               		lda 	(pctr),y
    30  2165 8517               		sta 	instr+1
    31  2167 c8                 		iny
    32  2168 b110               		lda 	(pctr),y
    33  216a 8516               		sta 	instr
    34                          		;
    35  216c 20dc21             		jsr 	ShowDebugInfo 				; current state if debugging
    36                          		;
    37  216f a510               		lda 	pctr 						; bump pctr
    38  2171 18                 		clc 
    39  2172 6902               		adc 	#2
    40  2174 8510               		sta 	pctr
    41  2176 9002               		bcc 	+
    42  2178 e611               		inc 	pctr+1
    43                          +
    44  217a 03                 		!byte 	$03
    45                          
    46  217b a517               		lda 	instr+1 					; get instr MSN and double it, so shift right thrice.
    47  217d 4a                 		lsr
    48  217e 4a                 		lsr
    49  217f 4a                 		lsr
    50  2180 291e               		and 	#$1E 						; force into range
    51  2182 aa                 		tax
    52                          
    53  2183 bd9021             		lda 	execTable,x 				; get address and go there.
    54  2186 8518               		sta 	temp0
    55  2188 bd9121             		lda 	execTable+1,x
    56  218b 8519               		sta 	temp0+1
    57  218d 6c1800             		jmp 	(temp0)
    58                          
    59                          execTable
    60  2190 b021               		!word 	notImplemented 				; $0x
    61  2192 b021               		!word 	notImplemented 				; $1x
    62  2194 b021               		!word 	notImplemented 				; $2x
    63  2196 b021               		!word 	notImplemented 				; $3x
    64  2198 b021               		!word 	notImplemented 				; $4x
    65  219a b021               		!word 	notImplemented 				; $5x
    66  219c b021               		!word 	notImplemented 				; $6x
    67  219e b021               		!word 	notImplemented 				; $7x
    68  21a0 b021               		!word 	notImplemented 				; $8x
    69  21a2 b021               		!word 	notImplemented 				; $9x
    70  21a4 b021               		!word 	notImplemented 				; $Ax
    71  21a6 b021               		!word 	notImplemented 				; $Bx
    72  21a8 b021               		!word 	notImplemented 				; $Cx
    73  21aa b021               		!word 	notImplemented 				; $Dx
    74  21ac b021               		!word 	notImplemented 				; $Ex
    75  21ae b021               		!word 	notImplemented 				; $Fx
    76                          
    77                          notImplemented								; come here when not implemented.
    78  21b0 a2ee               		ldx 	#$EE
    79  21b2 8a                 		txa
    80  21b3 a8                 		tay
    81  21b4 03                 		!byte 	$03

; ******** Source: main.asm

; ******** Source: utility.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       utility.asm
     5                          ;      Purpose:    Utility routines
     6                          ;      Created:    27th December 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;											Erase data memory
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          ClearMemory:
    19  21b5 ad0c21             		lda 	initStart 					; start erasing from here
    20  21b8 8518               		sta 	temp0
    21  21ba ad0d21             		lda 	initStart+1
    22  21bd 8519               		sta 	temp0+1
    23  21bf a000               		ldy 	#0		
    24                          _CLMLoop:
    25  21c1 a518               		lda 	temp0 						; done the lot ?
    26  21c3 cd0e21             		cmp 	initEnd
    27  21c6 d008               		bne 	_CLMClear
    28  21c8 a519               		lda 	temp0+1
    29  21ca cd0f21             		cmp 	initEnd+1
    30  21cd d001               		bne 	_CLMClear
    31  21cf 60                 		rts		
    32                          _CLMClear:
    33  21d0 98                 		tya 								; zero location and advance.
    34  21d1 9118               		sta 	(temp0),y
    35  21d3 e618               		inc 	temp0
    36  21d5 d0ea               		bne 	_CLMLoop
    37  21d7 e619               		inc 	temp0+1
    38  21d9 4cc121             		jmp 	_CLMLoop
    39                          
    40                          ; ***************************************************************************************************************
    41                          ;
    42                          ;										Show debug information
    43                          ;
    44                          ; ***************************************************************************************************************
    45                          
    46                          ShowDebugInfo:
    47  21dc a511               		lda 	pctr+1
    48  21de 20fb21             		jsr 	PrintHexSpace
    49  21e1 a510               		lda 	pctr
    50  21e3 200222             		jsr 	PrintHex
    51  21e6 a517               		lda 	instr+1
    52  21e8 20fb21             		jsr 	PrintHexSpace
    53  21eb a516               		lda 	instr
    54  21ed 200222             		jsr 	PrintHex
    55  21f0 a513               		lda 	register+1
    56  21f2 20fb21             		jsr 	PrintHexSpace
    57  21f5 a512               		lda 	register
    58  21f7 200222             		jsr 	PrintHex
    59  21fa 60                 		rts		
    60                          
    61                          ; ***************************************************************************************************************
    62                          ;
    63                          ;						PrintA as hex constant with/without leading space
    64                          ;
    65                          ; ***************************************************************************************************************
    66                          
    67                          PrintHexSpace:
    68  21fb 48                 		pha
    69  21fc a920               		lda 	#' '
    70  21fe 204421             		jsr 	PrintCharacter
    71  2201 68                 		pla
    72                          PrintHex:        
    73  2202 48                 		pha
    74  2203 4a                 		lsr     
    75  2204 4a                 		lsr     
    76  2205 4a                 		lsr     
    77  2206 4a                 		lsr     
    78  2207 200b22             		jsr     _PrintNibble
    79  220a 68                 		pla
    80                          _PrintNibble:
    81  220b 48                 		pha
    82  220c 290f               		and     #15
    83  220e c90a               		cmp     #10
    84  2210 9002               		bcc     +
    85  2212 6906               		adc     #6
    86                          +
    87  2214 6930               		adc     #48
    88  2216 204421             		jsr     PrintCharacter
    89  2219 68                 		pla 
    90  221a 60                 		rts

; ******** Source: main.asm
    75                          
    76                          ; ***************************************************************************************************************
    77                          ;
    78                          ;						Testing code goes here (this is for non runtime builds)
    79                          ;
    80                          ; ***************************************************************************************************************
    81                          
    82                          codeSpace:
    83  221b 205621             		jsr 	execRuntime
    84  221e 0001               		+cmd 	0,1
    85                          
    86                          ; ***************************************************************************************************************
    87                          ;
    88                          ;					Then the variables with predefined values, constants, addresses etc.
    89                          ;
    90                          ; ***************************************************************************************************************
    91                          
    92  2220 eaeaeaeaeaeaeaea...		!align 	255,0 						; put on page boundary.
    93                          SystemVariables:
    94  2300 3412               		!word 	$1234
    95  2302 c2ab               		!word 	$ABC2
    96                          
    97                          ; ***************************************************************************************************************
    98                          ;
    99                          ;									Then the uninitialised variables
   100                          ;
   101                          ; ***************************************************************************************************************
   102                          
   103                          UnnitialisedVariables:
   104                          		!if target > 0 { 					; allocate memory if not runtime build.
   105  2304 ffffffffffffffff...			!fill 	variableMax * 2,$FF
   106                          		}
   107                          EndVariableSpace:
